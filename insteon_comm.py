#!/usr/bin/env python
# Copyright (C) 2013 Mikhail Afanasyev
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>

"""
Control insteon powerline modem.

Commands:
  aliases     -- show all aliases (from code and config file)
  list        -- list all linked devices
  ping [addr] [addr2...]
              -- ping specified devices. Ping all linked if no name given.
  watch       -- receive messages from the bus until ctrl+c is hit
  nop         -- make sure modem is up and immediately return
  send DEST CMD-OR-ALIAS
              -- send insteon direct message
  repsend DEST CMD-OR-ALIAS COUNT DELAY
              -- send insteon command COUNT times with DELAY inbetween.
  status [addr] [addr2...]
              -- get light status from all specified devices. If no addresses
                 given, queries all linked.
  rawplm BYTES [resp-len]
              -- send raw message to PLM. if resp-len is present, 
                 expect that many bytes in response.

Examples: 
 insteon_comm.py list
 insteon_comm.py ping
 insteon_comm.py ping 12-34-56 smart-bulb
 insteon_comm.py send 29-9E-2D off-fast
 insteon_comm.py send smart-bulb id-req -l 0.5
 insteon_comm.py send smart-bulb prod-data -l 0.5
 insteon_comm.py repsend smart-bulb dim 10
 insteon_comm.py status
 insteon_comm.py rawplm 02-73 3 
"""

import errno
import glob
import optparse
import os
import serial
import socket
import sys
import time

__version__ = '0.1'

class UserError(Exception):
    """Unique error which has plenty of info in message,
    and thus needs no strack trace"""

    pass

# Insteon device address aliases. 'this-modem' is autogenerated.
ALIASES_DEVADDR = {
    'this-modem': 'autodetected', # this line for documentation purposes only
    'smart-bulb': '29-9E-2D'
}

# Insteon command aliases.
ALIASES_COMMAND = {
    'ping':          '0F-00',
    'on':            '11-FF',
    'on-fast':       '12-FF',
    'on-50':         '12-80',
    'on-25':         '12-3F',
    'off':           '13-00',
    'off-fast':      '14-00',
    'brighten':      '15-00',
    'dim':           '16-00',    
    'auto-brighten': '17-01',
    'auto-dim':      '17-00',
    'auto-stop':     '18-00',

    'status':        '19-00', # 2nd byte is brightness level
    
    'prod-data':     '03-00', # use with -l
    'prod-text':     '03-02', # use with -l
    'id-req':        '10-00', # use with -l
}

# modem responses. Map: command -> (name, len)
# These are used to determine response length and to print
# data in verbose mode.
INSTEON_COMMANDS = {
    # Commands from modem to host
    0x50: ('rx-insteon-std', 9),
    0x51: ('rx-insteon-ext',  23),
    0x52: ('x10', 2),
    0x53: ('all-link-completed', 8),
    0x54: ('button-report', 1),
    0x55: ('user-reset-detected', 0),
    0x56: ('all-link-cleanup-fail', 5),
    0x57: ('all-link-response', 8),
    0x58: ('all-link-cleanup-status', 1),   
    }

class InsteonComm(object):
    # Default serial device -- an USB-FTDI converter.
    DEF_DEVICE = "/dev/serial/by-id/usb-FTDI_FT232R*"

    # We want to make sure that only one instance of program is running
    # at a time, so we need some locking. The proper way is to use
    # serial lockfile in /var/lock/LCK..ttyUSB..., but I am lazy,
    # so I'll just keep TCP port open.
    DEF_LOCK_PORT = 22836

    # Default response timeout. This is timeout until the first byte of the 
    # message.
    RESPONSE_TIMEOUT = 0.5
    
    # Inter-byte timeout -- once the message has started, how fast should the bytes go?
    BYTE_TIMEOUT = 0.1

    # Post-NAK timeout -- how long should line be idle after NAK before we retry?
    NAK_TIMEOUT = 0.25
    
    # Default INSTEON message flags. Lower 2 bits contains number of hops (0..3)
    INSTEON_MSG_FLAGS = 0x03

    # When sending a direct insteon message which is un-acked, retry up that many times
    # The retry is sent immedeately after timeout (by default RESPONSE_TIMEOUT) expires.
    INSTEON_RETRIES = 0

    def __init__(self, device=None, verbose=False, lock_port=None):
        self.start_time = time.time()
        self.verbose = verbose
        self.modem_addr = None
        self.lock_handle = None

        if device is None:
            device = self.DEF_DEVICE
        if '*' in device:
            clist = glob.glob(device)
            if len(clist) == 0:
                raise UserError('Cannot find serial device to match %r' % device)
            elif len(clist) > 1:
                raise UserError('Too many files match serial device %r:\n %s' % 
                                (device, '\n '.join(clist)))
            device = clist[0]

        if lock_port is None:
            lock_port = self.DEF_LOCK_PORT
        if lock_port:
            self.debug('Getting lock in form of a TCP socket localhost:%d' % (
                    lock_port))
            self.lock_handle = socket.socket()
            self.lock_handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                self.lock_handle.bind(('127.0.0.1', lock_port))
                # We do not have to listen(), but if we do not do this, the socket
                # does not show up in netstat or lsof, thus making very hard to 
                # determine who is holding it.
                self.lock_handle.listen(1)
            except socket.error as e:
                if e.errno != errno.EADDRINUSE:
                    raise
                raise UserError('Another instance of this program is running')

        self.debug('Opening serial port %r' % device)
        self.ser = serial.serial_for_url(device, baudrate=19200)
        self.flush_junk()
        self.ping_modem()
        
    def log(self, msg):
        print >>sys.stderr, '*', msg

    def debug(self, msg):
        if self.verbose:
            dt = time.time() - self.start_time
            print >>sys.stderr, "### %.3f: %s" % (dt, msg)
            
    def flush_junk(self):
        self.ser.setTimeout(0.1)
        for _ in range(20):
            junk = self.ser.read(32)
            if junk == '':
                break
            self.log('Discarding junk on serial port: %r' % junk)
        else:
            raise UserError('Too much junk on serial port... it is coming and coming')
        self.debug('Done flushing junk on serial port')

    def _read_packet(self, timeout=None, ack_code=None, ack_datalen=None):
        """Read a packet from serial link. Return list of ints,
        or empty list for timeout.
        """
        if timeout is None:
            timeout = self.RESPONSE_TIMEOUT
        self.ser.setTimeout(timeout)

        # read sync byte first 
        while True:
            sync_b = self.ser.read(1)
            if sync_b == '':
                self.debug('Read timed out (t=%.3f)' % timeout)
                return [] # timeout
            if sync_b == '\x02':
                break
            if sync_b == '\x15' and (ack_code is not None):
                # we got NAK to the command. Need to retry later.
                result = [ ord(sync_b) ]
                # NAKs often come in groups, so lets check if there is another one.
                self.ser.setTimeout(self.NAK_TIMEOUT)
                while len(result) < 64:
                    extra_b = self.ser.read(1)
                    if extra_b == '':
                        break
                    result.append(ord(extra_b))
                    if extra_b != '\x15':
                        self.log('Got non-junk byte %02X after NAK. Nex packet '
                                 'might be lost. If this happens often, '
                                 'implement unread()' % ord(extra_b))
                        break
                self.debug('RX-nak: %s' % self.format_rxpacket(result))
                return result
            self.log('Discarding pre-packet junk on serial port: 0x%02x' % (
                    ord(sync_b)))

        self.ser.setTimeout(self.BYTE_TIMEOUT)

        # read command byte
        code_b = self.ser.read(1)
        if code_b == '':
            raise UserError('Interrupted packet: no packet code')
        
        code = ord(code_b)
        if (ack_datalen is not None) and (code == ack_code):
            resp_len = ack_datalen
        else:
            resp_len = INSTEON_COMMANDS.get(code, ((None, 64)))[1]
        resp = self.ser.read(resp_len)
        result = [ord(x) for x in (sync_b + code_b + resp)]
        self.debug('RX: %s' % self.format_rxpacket(result))
        return result

    def send_packet(self, txbytes, data_len=0, nak_ok=False):
        """Send bytes, wait for response (ACK or NAK).
        Return list of data bytes (except ACK), or None if
        packet was nack'ed and nak_ok was set.
        All other errors cause exception.
        """
        data = ''.join(chr(x) for x in txbytes)
        self.debug('TX: %s' % self.format_bytes(txbytes))
        self.ser.write(data)

        # Note there are two kinds of PLM NAKs:
        # - if 0x15 is sent immediately, then PLM is busy. 
        #   command should be retried.
        # - if command is echoed back, followed by 0x15, then
        #   command is not executed. We raise exception.

        retries_left = 10 # How many retries after PLM NAKs
        while True:
            # We expect to get our packet echoed back, so lets warn
            # _read_packet function about this.
            resp = self._read_packet(
                ack_code=txbytes[1],
                ack_datalen=(data_len + len(txbytes) - 1))
            if not resp:
                raise Exception('PLM packet not acknowledged: %s' % (
                        self.format_bytes(txbytes)))

            if resp[0] == 0x15:
                retries_left -= 1
                if retries_left <= 0:
                    raise UserError('PLM keeps giving us NAKs. Is it broken?')
                # PLM busy, need to retry.
                self.ser.write(data)
                self.debug('TX-retry: %s' % self.format_bytes(txbytes))
                continue

            if resp[:2] == txbytes[:2]:
                # looks like our response
                break

            self.log('Unknown response to %s: %s (%d/%d bytes)' % (
                    self.format_bytes(txbytes), 
                    self.format_rxpacket(resp),
                    len(resp), (data_len + len(txbytes) + 1)))

        if resp[-1] == 0x15:
            # Got a NAK.
            if nak_ok:
                return None 
            else:
                raise UserError("Modem NAK'ed command %s" % 
                                self.format_bytes(txbytes))

        if (resp[:len(txbytes)] == txbytes and
            len(resp) == (data_len + len(txbytes) + 1) and 
            resp[-1] == 0x06):
            # Got full response and an ACK.
            return resp[len(txbytes):-1]

        raise Exception('Malformed response to %s: %s (%d/%d bytes)' % (
                self.format_bytes(txbytes), 
                self.format_rxpacket(resp),
                len(resp), (data_len + len(txbytes) + 1)))

        
    @staticmethod
    def format_bytes(sbytes):
        return '-'.join('%02X' % x for x in sbytes)

    INSTEON_MSG_TYPES = [
        'direct', 'ack', 'group-cleanup', 'group-cleanup-ack',
        'broadcast', 'nak', 'group-broadcast', 'group-cleanup-nak']

    def format_rxpacket(self, sbytes):
        if ((sbytes[:2] == [0x02, 0x50] and len(sbytes) == 11) or
            (sbytes[:2] == [0x02, 0x51] and len(sbytes) == 25)):
            # RX Insteon message
            flags = sbytes[8]
            mtype = self.INSTEON_MSG_TYPES[flags >> 5]            
            tags = [
                'type=%s' % mtype,
                'from=%s' % self.format_addr(sbytes[2:5])
                ]
            if mtype == 'broadcast':
                # Type, Subtype, Version
                tags += ['from-info=%s' % self.format_bytes(sbytes[5:8])]
            elif mtype.startswith('group'):
                tags += ['group=%s' % self.format_bytes(sbytes[5:8])]
            else:
                tags += ['to=%s' % self.format_addr(sbytes[5:8])]
                
            tags += [
                'cmd=%s' % self.format_bytes(sbytes[9:11]),
                'hops_left=%s/%s' % ((flags>>2) & 3, flags & 3)
                ]

            if len(sbytes) == 25:
                udata = sbytes[12:]
                if (sbytes[9:11] == [0x03, 0x00] and udata[0] == 0x00):
                    # product data response
                    tags += ['product-key=%s' % self.format_bytes(udata[1:4]),
                             'cat=0x%02X' % udata[4],
                             'subcat=0x%02X' % udata[5],
                             'reserved2=%s' % self.format_bytes(udata[7:9]),
                             'user=%s' % self.format_bytes(udata[9:])]
                elif (sbytes[9] == 0x03 and sbytes[10] in [0x02, 0x03]):
                    tags += [ 'text=%r' % ((''.join(chr(x) for x in udata)).rstrip('\x00')) ]
                else:
                    tags += [ 'user=%s' % self.format_bytes(udata) ]
                        
            return 'INSTEON(%s)' % (', '.join(tags))

        if (sbytes[:2] == [0x02, 0x52] and len(sbytes) == 4 
            and sbytes[3] in [0x80, 0x00]):
            X10_REORDER = [
                13, 5, 3, 11,  15, 7, 1, 9,
                14, 6, 4, 12,  16, 8, 2, 10]
            X10_COMMAND = [
                'all-units-off', 'all-units-on', 'on', 'off',
                'dim', 'bright', 'all-lights-off', 'ext-code',
                'hail-req', 'hail-ack', 'preset-a', 'preset-b',
                'ext-data', 'status-on', 'status-off', 'status-req'
                ]
            house_code = chr(ord('A') - 1 + X10_REORDER[sbytes[2] >> 4 - 1])
            if sbytes[3] == 0x80:
                return 'X10(house=%s, command=%s)' % (
                    house_code, X10_COMMAND[sbytes[2] & 0xF])
            else:
                return 'X10(house=%s, unit=%d)' % (
                    house_code, X10_REORDER[sbytes[2] & 0xF])                       
                        
        if sbytes[0] == 0x02 and sbytes[1] in INSTEON_COMMANDS:
            cmdname, dlen = INSTEON_COMMANDS[sbytes[1]]
            if len(sbytes) == dlen + 2:
                return '%s(cmd=%s, args=%s)' % (
                    cmdname, 
                    self.format_bytes(sbytes[:2]),
                    self.format_bytes(sbytes[2:]))

        return self.format_bytes(sbytes)

    def parse_bytes(self, sval, expected_len=None, what=None):
        result = []
        try:
            for tag in sval.strip().split('-'):
                val = int(tag.strip(), 16)
                if not 0 <= val <= 255:
                    raise ValueError()
                result.append(val)
            if expected_len is not None and len(result) != expected_len:
                raise ValueError()
        except ValueError:
            msg = '%r is not a valid ' % sval
            if what:
                msg += '%s (%d bytes or an alias)' % (
                    what, expected_len)
            else:
                if expected_len is not None:
                    msg += '%d byte ' % expected_len
                msg += 'hex string'
            raise UserError(msg)
        return result

    def format_addr(self, abytes, raw=False):
        """Convert 3-byte array to string. If printing to user, use %r format
        spec to add quotes properly.
        """
        assert len(abytes) == 3
        if abytes == self.modem_addr:
            return 'this-modem'
        resp = self.format_bytes(abytes)
        revaliases = dict(reversed(x) for x in ALIASES_DEVADDR.items())
        if resp not in revaliases:
            return resp
        if raw:
            return "%s[%s]" % (revaliases[resp], resp)
        return revaliases[resp]

    def parse_addr(self, sval):
        """Parse device address. Return a 3-byte array"""
        if sval == 'this-modem':
            return self.modem_addr
        sval = ALIASES_DEVADDR.get(sval, sval)
        abytes = self.parse_bytes(sval, 3, 'address')
        return abytes

    def ping_modem(self, verbose=False):
        """Ping poweline modem. Raise exception if it does not respond
        properly"""
        resp = self.send_packet([0x02, 0x60], data_len=6)
        modem_addr = resp[:3]
        if modem_addr != self.modem_addr:
            assert self.modem_addr is None
            self.modem_addr = modem_addr
            self.debug('Setting modem_addr to %s' % (
                    self.format_bytes(modem_addr)))

        if verbose:
            self.log('Found modem with address %r, devinfo %r' % (
                    self.format_bytes(modem_addr), self.format_bytes(resp[3:])))
          
    def get_linked_devices(self):
        """Get a list of linked devices from PLM. Return list of dicts."""
        result = []
        resp = self.send_packet([0x02, 0x69], nak_ok=True) # Get First All-link record
        while True:
            if resp is None: #NAK
                return result
            data = self._read_packet()
            assert data[:2] == [0x02, 0x57], data
            result.append(
                dict(rflags = data[2], group=data[3],
                     addr = data[4:7], linkdata=data[7:]))
            resp = self.send_packet([0x02, 0x6A], nak_ok=True) # Get Next All-link record

    def send_insteon_direct(self, addr, cmd1, cmd2, error_ok=False, ack_data=False,
                            retries=None):
        """Send an INSTEON message and wait for ack.
        returns: None if no response
                 False if NAK'ed (reason is discarded)
                 True if ACK'ed and ack_data is False
                 2-byte list if ACK'ed and ack_data is True
        """
        assert len(addr) == 3

        if retries is None:
            retries = self.INSTEON_RETRIES
            
        flags = self.INSTEON_MSG_FLAGS
        txpacket = [0x02, 0x62] + addr + [flags, cmd1, cmd2]
        self.send_packet(txpacket)

        while True:
            msg = self._read_packet()
            if msg == []:
                # Timed out
                if retries > 0:
                    retries -= 1
                    self.log('No response from %r on message %s, retrying (%d retries left)' % (
                            self.format_addr(addr), self.format_bytes([cmd1, cmd2]), retries))
                    self.send_packet(txpacket)
                    continue
                    
                if not error_ok:
                    raise UserError('No response from %r on message %s' % (
                            self.format_addr(addr), self.format_bytes([cmd1, cmd2])))
                return None  # no response

            if (msg[:8] == ([0x02, 0x50] + addr + self.modem_addr) and
                (msg[8] >> 5) in [1, 5]):
                # This is an ACK/NAK packet for our message
                acked = (msg[8] >> 5) == 1
                adata = msg[9:11]
                if not (acked or error_ok):
                    raise UserError('NAK response from %r on message %s' % (
                            self.format_addr(addr), self.format_bytes([cmd1, cmd2])))
                if not acked:
                    return False
                if ack_data: 
                    return adata
                if adata != [cmd1, cmd2]:
                    raise UserError('Invalid ACK response from %r: '
                                    'cmd contains %s instead of expected %s' % (
                            self.format_addr(addr), self.format_bytes(adata), 
                            self.format_bytes([cmd1, cmd2])))
                return True

            self.log('Unexpected message while waiting for ACK: %s' % self.format_rxpacket(msg))


    def ping_device(self, addr):
        """Send a PING command to a specified device. Return True if device responds,
        False if it is down, exception for other errors.
        """
        return self.send_insteon_direct(addr, 0x0F, 0x00, error_ok=True,
                                        retries=0)

    def listen_for(self, duration, stdout=False):
        """Receive messages for @p duration seconds. Should be used
        instead of time.sleep()
        If stdout is True, prints all messages to stdout; else they appear 
        as log entries.
        """
        t_stop = time.time() + duration
        while True:
            t_left = max(0, t_stop - time.time())
            if t_left == 0:
                break
            msg = self._read_packet(timeout=t_left)
            if msg == []: 
                break
            if stdout:
                print self.format_rxpacket(msg)
                sys.stdout.flush()
            else:
                self.log('Unexpected message while waiting: ' %
                         self.format_rxpacket(msg))


def main():   
    parser = optparse.OptionParser(
        usage='%prog [options] command [args]',
        description=__doc__, version=__version__)
    parser.format_description = lambda _: parser.description.lstrip()

    parser.add_option('-D', '--device', metavar='FNAME',
                      help='Serial port to use')
    parser.add_option('--lock-port', metavar='NUM', type='int',
                      help='TCP port used to make sure only once instance'
                      'of this programm is running. 0 to disable.')
    parser.add_option('-l', '--listen-for', metavar='S', type='float',
                      help='After successful command, listen for S seconds')
    parser.add_option('-r', '--retry', metavar='N', type='int', 
                      default=InsteonComm.INSTEON_RETRIES,
                      help='If insteon device does not respond, retry that'
                      ' many times (default %default)')
    parser.add_option('-v', '--verbose', action='store_true',
                      help='Print more info')
    opts, args = parser.parse_args()

    def make_comm():
        comm = InsteonComm(device=opts.device,
                           verbose=opts.verbose,
                           lock_port=opts.lock_port)
        comm.INSTEON_RETRIES = opts.retry
        return comm

    if len(args) == 0:
        parser.error('No command specified. Try -h.')

    comm = None

    if args[0] == 'list':
        if len(args) != 1:
            parser.error('Too many arguments')
        comm = make_comm()
        comm.ping_modem(verbose=True)
        print 'Device list:'
        for dev in comm.get_linked_devices():
            print ' Device %r in group %d, flags 0x%X, linkdata %s' % (
                comm.format_addr(dev['addr'], raw=True), dev['group'], dev['rflags'],
                comm.format_bytes(dev['linkdata']))

    elif args[0] == 'aliases':
        for (descr, data) in (
            ('Device Address', ALIASES_DEVADDR),
            ('Insteon Command', ALIASES_COMMAND)):
            print
            print '%s Aliases' % descr
            for name, val in sorted(data.items()):
                print ' %-20s: %s' % (name, val)

    elif args[0] == 'ping':
        comm = make_comm()
        to_ping = [ comm.parse_addr(a)
                    for a in args[1:] ]
        if len(to_ping) == 0:
            devs = comm.get_linked_devices()
            to_ping = [dev['addr'] for dev in devs]

        failed = False
        for addr in to_ping:
            result = comm.ping_device(addr)
            if result is None:
                failed = True
                result_s = 'TIMEOUT'
            elif result is False:
                failed = True
                result_s = 'NAK'
            else:
                result_s = 'SUCCESS(%r)' % (result, )
            print 'Pinging %r: %s' % (
                comm.format_addr(addr), result_s)

        if failed:
            return 1

    elif args[0] == 'watch':
        if len(args) != 1:
            parser.error('Too many arguments')
        comm = make_comm()
        while True:
            msg = comm._read_packet(timeout=30.0)
            if msg == []:
                continue
            print comm.format_rxpacket(msg)
            sys.stdout.flush()
       
    elif args[0] == 'nop':
        if len(args) != 1:
            parser.error('Too many arguments')
        comm = make_comm()

    elif args[0] == 'send':
        if len(args) != 3:
            parser.error('Wrong number of arguments')
        comm = make_comm()
        addr = comm.parse_addr(args[1])
        
        cmd = comm.parse_bytes(ALIASES_COMMAND.get(args[2], args[2]), 2,
                               what='command')
        res = comm.send_insteon_direct(addr, cmd[0], cmd[1], 
                                       error_ok=True, ack_data=True)
        if res is None:
            print 'NO-RESPONSE'
            return 1
        elif res is False:
            print 'NAK'
            return 2
        else:
            print 'ACK %s' % comm.format_bytes(res)

    elif args[0] == 'repsend':
        if len(args) not in [4, 5]:
            parser.error('Wrong number of arguments')

        comm = make_comm()
        addr = comm.parse_addr(args[1])
        
        cmd = comm.parse_bytes(ALIASES_COMMAND.get(args[2], args[2]), 2,
                               what='command')
        
        count = int(args[3])
        if len(args) > 4:
            delay = float(args[4])
        else:
            delay = 0.5
        
        for step in range(1, count+1):
            res = comm.send_insteon_direct(addr, cmd[0], cmd[1], 
                                           error_ok=True, ack_data=True)
            if res is None:
                print 'Step %d: NO-RESPONSE' % step
                return 1
            elif res is False:
                print 'Step %d: NAK' % step
                return 2
            else:
                print 'Step %d: ACK %s' % (step, comm.format_bytes(res))
            comm.listen_for(delay)

    elif args[0] == 'status':
        comm = make_comm()
        to_poll = [ comm.parse_addr(a)
                    for a in args[1:] ]
        if len(to_poll) == 0:
            devs = comm.get_linked_devices()
            to_poll = [dev['addr'] for dev in devs]

        failed = False
        for addr in to_poll:
            result = comm.send_insteon_direct(addr, 0x19, 0x00, 
                                              error_ok=True, ack_data=True)
            if result is None:
                failed = True
                result_s = 'TIMEOUT'
            elif result is False:
                failed = True
                result_s = 'NAK'
            else:
                result_s = "%1.f%% (0x%02X)" % (
                    result[1] * 100.0 / 255, result[1])
            if len(args) == 2:
                # only one device, explicitly specified
                print result_s
            else:
                print 'status of %r: %s' % (
                    comm.format_addr(addr), result_s)

        if failed:
            return 1

    elif args[0] == 'rawplm':
        if len(args) not in [2, 3]:
            parser.error('Wrong number of arguments')
            
        comm = make_comm()
        cmd = comm.parse_bytes(args[1])
        if len(args) > 2:
            data_len = int(args[2])
        else:
            data_len = 0

        resp = comm.send_packet(cmd, data_len, nak_ok=True)
        if resp is None:
            print 'NAK'
        else:
            print comm.format_bytes(resp)

    else:
        parser.error('Unknown command %r' % args[0])

    if opts.listen_for and comm:
        comm.listen_for(opts.listen_for, stdout=True)
        
if __name__ == '__main__':
    try:
        sys.exit(main())
    except UserError as e:
        print >>sys.stderr, 'FATAL ERROR: %s' % e
        sys.exit(99)
